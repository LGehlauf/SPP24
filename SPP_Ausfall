import simpy
import pandas as pd
import numpy as np
import random
import matplotlib.pyplot as plt

# Festlegen der Parameter
REPAIR_TIME = 180          # Reparaturzeit in Sekunden
MTTF = 3000                # Mean time to failure in Sekunden (mittlere Zeit bis zum Ausfall)
SIM_TIME = 10000           # Simulationsdauer in Sekunden
PLANNED_DOWNTIME = 480     # Geplante Stillstandszeit in Sekunden (8 Stunden)
RUN_TIME = 960             # Laufzeit in Sekunden (16 Stunden)

# Listen zur Protokollierung der Startzeiten, Reparaturen und Stillstandszeiten
startzeiten = []
zustand_counts = {
    'Bearbeitung': 0,
    'Ausfall': 0,
    'Geplanter Stillstand': 0
}

# Funktion zur Erzeugung einer zufälligen Ausfallzeit
def time_to_failure():
    """Gibt die Zeit bis zum nächsten Ausfall für eine Maschine zurück."""
    return random.expovariate(1 / MTTF)

class Maschine:
    def __init__(self, env, maschinentyp, kapazitaet):
        self.env = env
        self.maschinentyp = maschinentyp
        self.maschinenkapa = simpy.Resource(env, kapazitaet)
        self.broken = False

        # Starte den Prozess für Maschinenaufrufe
        self.env.process(self.break_machine())
        self.env.process(self.planned_downtime())

    def Bearbeitung(self, bauteil):
        self.env.process(self.Drehen(bauteil))

    def Drehen(self, bauteil):
        while bauteil.zaehler < bauteil.anzahl:
            start = self.env.now
            print('Starte Bearbeitung von Teil', bauteil.zaehler + 1)

            # Warten auf die Ressource (Maschine)
            with self.maschinenkapa.request() as request:
                yield request  # Anforderung der Ressource

                # Falls die Maschine nicht defekt ist, fahren wir fort
                if not self.broken:
                    # Bauteil anfordern
                    yield bauteil.bauteilcontainer.get(1)
                    print(f"Bauteil angefordert; t[s]={env.now}")

                    # Produktionsprozess simulieren
                    bearbeitungszeit = bauteil.get_drehteil()[0, 0]
                    yield env.timeout(bearbeitungszeit)
                    print(f"CNC-Programm einlesen; t[s]={env.now}")
                    yield env.timeout(180)  # Simuliert weiteres Bearbeiten

                    # Bearbeitung abgeschlossen
                    print(f"Teil fertiggestellt; t[s]={env.now}")
                    bauteil.Bauteilzaehler()

                    # Protokollierung der Startzeit
                    startzeiten.append({
                        'Teil': bauteil.zaehler,
                        'Startzeit': start,
                        'Endzeit': env.now,
                        'Status': 'Bearbeitung abgeschlossen'
                    })

                    # Zustand der Maschine aktualisieren
                    zustand_counts['Bearbeitung'] += (bearbeitungszeit + 180)  # Bearbeitungszeit + zusätzliche Zeit

            # Hier ist der Punkt, an dem die Maschine möglicherweise ausfallen kann
            if self.broken:
                print(f"{self.maschinentyp} ist defekt und wird repariert bei t[s]={env.now}")
                start_repair = env.now
                yield env.timeout(REPAIR_TIME)  # Reparaturzeit
                self.broken = False
                print(f"{self.maschinentyp} wurde repariert bei t[s]={env.now}")

                # Protokollierung des Ausfalls und der Reparatur
                startzeiten.append({
                    'Teil': bauteil.zaehler,
                    'Startzeit': start_repair,
                    'Endzeit': env.now,
                    'Status': 'Repariert'
                })

                # Zustand der Maschine aktualisieren
                zustand_counts['Ausfall'] += REPAIR_TIME  # Reparaturzeit zählt als Ausfallzeit

    def break_machine(self):
        """Maschine bricht nach einer bestimmten Zeit ab."""
        while True:
            yield self.env.timeout(time_to_failure())
            if not self.broken:
                # Maschine ausfallend, da sie gerade arbeitet
                self.broken = True
                print(f"{self.maschinentyp} fällt aus bei t[s]={self.env.now}")

    def planned_downtime(self):
        """Geplante Stillstandszeiten."""
        while True:
            # Maschinenlaufzeit
            yield self.env.timeout(RUN_TIME)  # 16 Stunden in Sekunden
            print(f"{self.maschinentyp} geht für geplante Stillstandszeit bei t[s]={self.env.now}")

            # Stillstandszeit
            start_downtime = self.env.now  # Protokolliere den Zeitpunkt des Stillstands
            yield self.env.timeout(PLANNED_DOWNTIME)  # 8 Stunden in Sekunden
            print(f"{self.maschinentyp} kommt nach Stillstandszeit zurück bei t[s]={self.env.now}")

            # Protokollierung der geplanten Stillstandszeit
            startzeiten.append({
                'Teil': None,  # Kein spezifisches Teil, da dies ein geplanter Stillstand ist
                'Startzeit': start_downtime,
                'Endzeit': self.env.now,
                'Status': 'Geplanter Stillstand'
            })

            # Zustand der Maschine aktualisieren
            zustand_counts['Geplanter Stillstand'] += PLANNED_DOWNTIME  # Geplante Stillstandszeit

class Bauteil:
    def __init__(self, env, teiletyp, zeit, anzahl):
        self.env = env
        self.teiletyp = teiletyp
        self.zeit = zeit
        self.anzahl = anzahl
        self.zaehler = 0
        self.bauteilcontainer = simpy.Container(env, anzahl, init=anzahl)

    def Drehteil(self):
        if self.teiletyp == 'Drehteil':
            self.zeit = np.loadtxt('Daten.csv', delimiter=';')  # Import von den Daten aus der CSV
            print(self.zeit)

    def Bauteilzaehler(self):
        if self.zaehler < self.anzahl:
            self.zaehler += 1
            print('Teile hergestellt:', self.zaehler)
            print('Noch zu produzieren:', self.anzahl - self.zaehler)

    def get_drehteil(self):
        return self.zeit

# Simulationsumgebung erstellen
env = simpy.Environment()

# Bauteil erstellen und Initialisierungen
bauteil1 = Bauteil(env, 'Drehteil', 10, 9)
bauteil1.Drehteil()

# Maschine erstellen
m1 = Maschine(env, 'Drehmaschine', 1)
m1.Bearbeitung(bauteil1)

# Simulation starten
env.run(until=SIM_TIME)

# Startzeiten in DataFrame speichern und als CSV exportieren
startzeiten_df = pd.DataFrame(startzeiten)
startzeiten_df.to_csv('startzeiten_mit_ausfaellen.csv', index=False)
print("Die Startzeiten inklusive Ausfälle und Reparaturen sowie geplante Stillstandszeiten wurden in 'startzeiten_mit_ausfaellen.csv' gespeichert.")

# Tortengrafik erstellen
labels = zustand_counts.keys()
sizes = zustand_counts.values()

plt.figure(figsize=(8, 8))
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
plt.title('Zustand der Maschine')
plt.axis('equal')  # Gleichmäßige Darstellung
plt.savefig('zustand_maschine.png')  # Speichern als PNG
plt.show()  # Anzeigen der Tortengrafik
